
import * as XLSX from 'xlsx';
import saveAs from 'file-saver';
import html2canvas from 'html2canvas';
import JSZip from 'jszip';
import { jsPDF } from 'jspdf';
import { Participant, BingoCard } from '../types.ts';

// --- Excel Functions ---

export const exportToExcel = (participants: Participant[]) => {
  // Sheet 1: Participants
  const participantsData = participants.map(p => ({
    ID: p.id,
    Nombre: p.name,
    Apellidos: p.surname,
    DNI: p.dni,
    Telefono: p.phone || ''
  }));

  // Sheet 2: Cartones
  // We flatten the 25 numbers (including the 0 center) or just the 24 valid numbers.
  // To keep it simple for re-import logic, we will save all valid numbers sequentially N1..N24.
  // The center (0) is always implicit at index 12 during generation, so we don't need to save it if we just save valid numbers.
  const cardsData: any[] = [];
  participants.forEach(p => {
    p.cards.forEach(c => {
      const row: any = {
        ID_Part: p.id,
        ID_Carton: c.id,
      };
      // Filter out the 0 center to save clean data
      const validNumbers = c.numbers.filter(n => n !== 0);
      validNumbers.forEach((num, idx) => {
        row[`N${idx + 1}`] = num;
      });
      cardsData.push(row);
    });
  });

  const wb = XLSX.utils.book_new();
  const ws1 = XLSX.utils.json_to_sheet(participantsData);
  const ws2 = XLSX.utils.json_to_sheet(cardsData);

  XLSX.utils.book_append_sheet(wb, ws1, "Participantes");
  XLSX.utils.book_append_sheet(wb, ws2, "Cartones");

  const excelBuffer = XLSX.write(wb, { bookType: 'xlsx', type: 'array' });
  const blob = new Blob([excelBuffer], { type: 'application/octet-stream' });
  saveAs(blob, `bingo_participantes_${new Date().toISOString().slice(0, 10)}.xlsx`);
};

export const parseExcel = async (file: File): Promise<Participant[]> => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const data = new Uint8Array(e.target?.result as ArrayBuffer);
        const wb = XLSX.read(data, { type: 'array' });
        
        const wsP = wb.Sheets['Participantes'] || wb.Sheets[wb.SheetNames[0]];
        const wsC = wb.Sheets['Cartones'] || wb.Sheets[wb.SheetNames[1]];

        if (!wsP) throw new Error("No se encontró la hoja 'Participantes'");

        const rawPart = XLSX.utils.sheet_to_json(wsP) as any[];
        const rawCards = wsC ? XLSX.utils.sheet_to_json(wsC) as any[] : [];

        const participantsMap = new Map<string, Participant>();

        // Process Participants
        rawPart.forEach(r => {
          const id = r.ID ? String(r.ID) : `P${Math.random().toString(36).substr(2, 6)}`;
          participantsMap.set(id, {
            id,
            name: r.Nombre ? String(r.Nombre) : 'Sin Nombre',
            surname: r.Apellidos ? String(r.Apellidos) : '',
            dni: r.DNI ? String(r.DNI) : '',
            phone: r.Telefono ? String(r.Telefono) : '',
            cards: []
          });
        });

        // Process Cards
        rawCards.forEach(r => {
          const pId = r.ID_Part ? String(r.ID_Part) : null;
          if (!pId) return;

          const participant = participantsMap.get(pId);
          if (participant) {
            const numbers: number[] = [];
            // Read N1 to N24
            for (let i = 1; i <= 24; i++) {
              const val = parseInt(r[`N${i}`]);
              if (!isNaN(val)) numbers.push(val);
            }
            
            // If we read exactly 24 numbers, we need to reconstruct the 5x5 grid (inserting 0 at index 12)
            // Note: This assumes the Excel numbers were saved in the specific order generated by the app (Row by Row excluding center)
            if (numbers.length === 24) {
               numbers.splice(12, 0, 0); // Insert center placeholder
            }

            // Validation: If length is not 25 after insertion (or if data was malformed), 
            // this might render oddly, but we accept it for now.
            
            participant.cards.push({
              id: r.ID_Carton ? String(r.ID_Carton) : `C${Math.random().toString(36).substr(2, 4)}`,
              numbers: numbers
            });
          }
        });

        resolve(Array.from(participantsMap.values()));
      } catch (err) {
        reject(err);
      }
    };
    reader.onerror = (err) => reject(err);
    reader.readAsArrayBuffer(file);
  });
};

// --- Image & PDF Generation Functions ---

const createTempCardElement = (participant: Participant, card: BingoCard, title: string, subtitle: string = ""): HTMLElement => {
  const container = document.createElement('div');
  Object.assign(container.style, {
    width: '600px',
    padding: '40px',
    backgroundColor: '#ffffff', // Pure white for PDF
    color: '#0f172a', 
    fontFamily: "'Inter', sans-serif",
    position: 'absolute',
    top: '-9999px',
    left: '-9999px',
    boxSizing: 'border-box',
  });

  // Header Section matching the "BINGO VIRTUAL" clean design
  const header = `
    <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 20px;">
      <div style="max-width: 75%;">
        <h1 style="font-size: 32px; font-weight: 900; margin: 0; color: #1e293b; letter-spacing: -1px; line-height: 1.1; text-transform: uppercase;">${title}</h1>
        ${subtitle ? `<div style="font-size: 14px; color: #64748b; font-weight: 600; margin-top: 6px; text-transform: uppercase; letter-spacing: 0.5px;">${subtitle}</div>` : ''}
        <div style="margin-top: 15px;">
           <div style="font-size: 22px; font-weight: 700; color: #334155; line-height: 1.2;">${participant.name} ${participant.surname}</div>
           <div style="font-size: 16px; color: #64748b;">DNI: ${participant.dni}</div>
        </div>
      </div>
      <div style="text-align: right;">
        <div style="font-size: 36px; font-weight: 800; color: #0f172a;">#${card.id}</div>
        <div style="font-size: 14px; color: #94a3b8; margin-top: 4px;">${new Date().toLocaleDateString()}</div>
      </div>
    </div>
    
    <div style="border-bottom: 2px solid #e2e8f0; margin-bottom: 20px;"></div>
  `;

  // Grid Section with dark rounded cells
  let gridHtml = `
    <table style="width: 100%; border-collapse: separate; border-spacing: 10px;">
       <thead>
        <tr>
          ${['B','I','N','G','O'].map(l => 
            `<th style="
                text-align: center; 
                font-size: 42px; 
                font-weight: 900; 
                color: #475569; 
                padding-bottom: 10px;
                line-height: 1;
            ">${l}</th>`
          ).join('')}
        </tr>
      </thead>
      <tbody>
  `;

  for(let r=0; r<5; r++) {
    gridHtml += '<tr>';
    for(let c=0; c<5; c++) {
      const index = r * 5 + c;
      const value = card.numbers[index];
      const isCenter = index === 12;

      const cellStyle = `
        width: 20%;
        height: 80px;
        background-color: #1e293b; /* Dark Slate */
        color: white;
        border-radius: 12px;
        text-align: center;
        vertical-align: middle;
        font-size: 34px;
        font-weight: 700;
        padding: 0;
        margin: 0;
        line-height: 1;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
      `;

      const contentWrapper = `display:flex; justify-content:center; align-items:center; height:100%; width: 100%;`;

      if (isCenter) {
        gridHtml += `
          <td style="${cellStyle}">
             <div style="${contentWrapper}">
                <svg width="36" height="36" viewBox="0 0 24 24" fill="#cbd5e1" stroke="none" xmlns="http://www.w3.org/2000/svg" style="opacity: 0.5;">
                   <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                </svg>
             </div>
          </td>`;
      } else {
        gridHtml += `<td style="${cellStyle}"><div style="${contentWrapper}">${value}</div></td>`;
      }
    }
    gridHtml += '</tr>';
  }

  gridHtml += `</tbody></table>`;

  const footer = `
    <div style="margin-top: 25px; border-top: 1px dashed #cbd5e1; padding-top: 15px; text-align: center; font-size: 12px; color: #94a3b8; font-weight: 500;">
      <div>¡Buena suerte! • Sistema de Bingo Virtual</div>
      <div style="font-size: 10px; margin-top: 4px; opacity: 0.8; color: #cbd5e1;">By Owoweb</div>
    </div>
  `;

  container.innerHTML = header + gridHtml + footer;
  return container;
};

export const downloadCardImage = async (participant: Participant, card: BingoCard, title: string = "BINGO VIRTUAL", subtitle: string = "") => {
  const el = createTempCardElement(participant, card, title, subtitle);
  document.body.appendChild(el);
  try {
    const canvas = await html2canvas(el, { scale: 2, useCORS: true, backgroundColor: '#ffffff' });
    const blob = await new Promise<Blob | null>(resolve => canvas.toBlob(resolve, 'image/png'));
    if (blob) {
      saveAs(blob, `bingo_${participant.name.replace(/\s+/g,'_')}_${card.id}.png`);
    }
  } finally {
    document.body.removeChild(el);
  }
};

export const downloadAllCardsZip = async (participants: Participant[], title: string = "BINGO VIRTUAL", subtitle: string = "") => {
  const zip = new JSZip();
  const folder = zip.folder("cartones_bingo");
  
  for (const p of participants) {
    for (const card of p.cards) {
      const el = createTempCardElement(p, card, title, subtitle);
      document.body.appendChild(el);
      try {
        const canvas = await html2canvas(el, { scale: 1.5, backgroundColor: '#ffffff' });
        const dataUrl = canvas.toDataURL('image/png');
        const base64 = dataUrl.split(',')[1];
        folder?.file(`${p.name.replace(/\s+/g,'_')}_${card.id}.png`, base64, { base64: true });
      } finally {
        document.body.removeChild(el);
      }
    }
  }

  const content = await zip.generateAsync({ type: "blob" });
  saveAs(content, "todos_cartones.zip");
};

export const generateBingoCardsPDF = async (participant: Participant, title: string, subtitle: string = "", specificCardId?: string) => {
  // Initialize PDF in A4 Portrait (mm)
  const doc = new jsPDF({
    orientation: 'portrait',
    unit: 'mm',
    format: 'a4'
  });

  // A4 Dimensions: 210mm x 297mm
  const pageWidth = 210;
  const pageHeight = 297;
  const margin = 10;
  const gap = 10;
  
  // Grid Calculations (2 columns, 2 rows)
  const cardWidth = (pageWidth - (margin * 2) - gap) / 2; // approx 90mm
  const cardHeight = (pageHeight - (margin * 2) - gap) / 2; // approx 133.5mm

  // Positions for 4 cards
  const positions = [
    { x: margin, y: margin },                                   // Top-Left
    { x: margin + cardWidth + gap, y: margin },                 // Top-Right
    { x: margin, y: margin + cardHeight + gap },                // Bottom-Left
    { x: margin + cardWidth + gap, y: margin + cardHeight + gap } // Bottom-Right
  ];

  const cardsToProcess = specificCardId 
    ? participant.cards.filter(c => c.id === specificCardId)
    : participant.cards;

  if (cardsToProcess.length === 0) return;

  for (let i = 0; i < cardsToProcess.length; i++) {
    const card = cardsToProcess[i];
    const posIndex = i % 4;

    // Add new page if we filled the previous 4 slots
    if (i > 0 && posIndex === 0) {
      doc.addPage();
    }

    // Render card to image
    const el = createTempCardElement(participant, card, title, subtitle);
    document.body.appendChild(el);
    
    try {
      // Use reasonable scale for PDF quality
      const canvas = await html2canvas(el, { scale: 2, backgroundColor: '#ffffff' });
      const imgData = canvas.toDataURL('image/jpeg', 0.9); // slightly compressed JPEG for smaller PDF size

      let pos = positions[posIndex];
      
      // If generating a single specific card, center it on the page for better presentation
      if (specificCardId && cardsToProcess.length === 1) {
        pos = {
            x: (pageWidth - cardWidth) / 2,
            y: (pageHeight - cardHeight) / 2
        };
      }
      
      // Calculate aspect ratio to fit within the grid cell
      const imgProps = doc.getImageProperties(imgData);
      const pdfRatio = cardWidth / cardHeight;
      const imgRatio = imgProps.width / imgProps.height;

      let w = cardWidth;
      let h = cardHeight;

      // Fit contain logic
      if (imgRatio > pdfRatio) {
        h = w / imgRatio;
      } else {
        w = h * imgRatio;
      }
      
      // Center in cell (or page if overridden above)
      const xCentered = pos.x + (cardWidth - w) / 2;
      const yCentered = pos.y + (cardHeight - h) / 2;

      doc.addImage(imgData, 'JPEG', xCentered, yCentered, w, h);
      
      // Optional: Add a light border around the card area for cutting reference
      doc.setDrawColor(200, 200, 200);
      doc.rect(xCentered, yCentered, w, h);

    } finally {
      document.body.removeChild(el);
    }
  }

  // Save the PDF
  let fileName = `Cartones_Bingo_${participant.name.replace(/\s+/g, '_')}.pdf`;
  if (specificCardId) {
      fileName = `Bingo_${participant.name.replace(/\s+/g, '_')}_${specificCardId}.pdf`;
  }
  doc.save(fileName);
  
  return fileName;
};
